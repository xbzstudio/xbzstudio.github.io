{"./":{"url":"./","title":"主页","keywords":"","body":" icodeapi icodeapi是一个强大的、快速的、支持同步和异步的有道小图灵社区API框架。它运行在Python当中。由xbzstudio开发。TuringAPI是它的前身。 安装 可以使用pip安装icodeapi。 pip install icodeapi 环境要求 Python版本：≥3.10依赖项：httpx, urllib3, aiofiles 查看icodeapi版本和信息 输入命令 pip show icodeapi 测试 使用以下指令测试您是否成功安装了icodeapi pip show icodeapi 或使用Python代码： try: import icodeapi import icodeapi.tools print(True) except: print(False) Github仓库地址PyPI官方页面 "},"QuickStart.html":{"url":"QuickStart.html","title":"快速开始","keywords":"","body":"快速开始 浏览你想要了解的信息。登录账号 >>获取作品 >>获取用户 >> "},"Login.html":{"url":"Login.html","title":"登录账号","keywords":"","body":"登录你的账号 在有道小图灵社区中使用抓包工具获取你的Cookie，它被写在请求头中，十分容易获取。使用IcodeAPI类构建一个有道小图灵账户。 class IcodeAPI(): __cookie : str = '' userAgent : str = DEFAULT_USER_AGENT __info : dict = {} client : httpx.Client = None __loginStatus = False def __init__( self, cookie : str = '', userAgent : str = DEFAULT_USER_AGENT, httpxClient : httpx.Client = httpx.Client(), timeout : Union[int, float] = 10 ): self.__cookie = cookie.encode('utf-8') self.userAgent = userAgent self.client = httpxClient self.client.timeout = timeout self.login() __cookie : 账号的cookie，私有成员。userAgent ： 发送请求时使用的UA。__info ： 账号的信息，如果登录失败则为空字典，私有成员。client ： 所使用的httpx连接池。__loginStatus : 账号登录状态，如果Cookie有效，为真；如果Cookie无效，为假。私有成员。 init方法的timeout参数用于设置httpx连接池的连接超时时间，单位为秒。userAgent参数的默认值为一个icodeapi的全局常量。默认值为：'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.203'登陆账号示例： import icodeapi # 创建一个账号 cookie = input('请输入你的cookie: ') api = icodeapi.IcodeAPI(cookie = cookie) # 打印登录信息 print(f'登录{\"成功\" if api.getLoginStatus() else \"失败\"}，', '账号信息：\\n', api.getInfo()) 输出内容： 登陆成功， 账号信息： {'encryptionUserId':'...', 'userId': '...', 'name': '...', 'image': '...', 'mobile': '...', 'permissions': [], 'hasCourse': 0, 'userIdentity': '...', 'courseType': '...'} IcodeAPI类实际上使用login方法来使用__cookie成员进行登录，同时，login方法也可以用于在该类上重新登录一个账号，只需要填入一个新的Cookie。 login方法： def login(self, newCookie : str = None) -> dict login方法会使用self.__cookie进行登录，如果填入了newCookie参数，那么将会使用newCookie给self.__cookie进行赋值。如果检测到Cookie有效，那么会将self.__loginStatus设置为真，将self.__info设置为有道小图灵官方API返回的内容。如果Cookie无效，那么将self.__info设为空字典，并将self.__loginStatus设置为假。返回self.__info。另外，如果Cookie无效，将会抛出LoginError错误。self.__info的有效值通常有如下格式： { 'encryptionUserId': str, # 加密后的用户ID 'userId': str, # 用户ID 'name': str, # 用户名 'image': str, # 用户头像url 'permissions': list, # 用户权限（或课程） 'mobile': str, # 用户手机号 'hasCourse': bool, # 用户是否购买课程 'userIdentity': str # 用户身份（购课用户或非课用户） 'courseType': str # 用户所有课程的类型 } 获取用户信息 如果需要获取已登录账号的信息，可以使用getInfo方法。如果要判断IcodeAPI对象是否已经正确地登录上一个账号，可以使用getLoginStatus方法。getInfo方法会返回类的__info成员，getLoginStatus方法会返回类的__loginStatus成员。使用示例： import icodeapi cookie = input('输入你的Cookie: ') api = icodeapi.IcodeAPI(cookie) # 构建IcodeAPI对象 if api.getLoginStatus(): # 判断是否已经登录 print('账号的ID为', api.getInfo().get('userId')) # 获取用户信息并提取出ID else: print('Cookie无效') "},"GetWorks.html":{"url":"GetWorks.html","title":"获取作品","keywords":"","body":"获取作品信息 解析作品ID 使用getWorkIdFromUrl方法从作品url中提取作品的id。 def getWorkIdFromUrl(url : str) -> str 示例： from icodeapi import getWorkIdFromUrl print(getWorkIdFromUrl('https://icodeshequ.youdao.com/work/a1f09b5eb34a48dfbdc8dee59d130ec6')) 输出： a1f09b5eb34a48dfbdc8dee59d130ec6 获取作品信息 使用IcodeAPI.getWorkDetail方法获取一个作品的基本信息。 def getWorkDetail(self, workId : str, addBrowseNum : bool = True ) -> dict workId ： 作品idaddBrowseNum ： 是否增加浏览量 返回的字典格式通常如下： { 'id': str, # 作品id 'title': str, # 作品标题 'imgUrl': str, # 作品封面url 'description': str, # 作品简介 'type': int, # 作品类型 'userId': str, # 发布者用户id 'status': int, # 发布状态（1为未发布,2为已发布） 'likeNum': int, # 点赞数 'browseNum': int, # 浏览量 'enshrineNum': int, # 收藏量 'code': str, # 作品源码 'userName': str, # 发布者用户名 'userImage': str, # 发布者用户头像url 'haveLiked': bool , # 是否已点赞 'haveEnshrined': bool, # 是否收藏 'createTimeStr': str, # 创建时间 'updateTimeStr': str, # 更新时间 'codeLanguage': str, # 代码语言（blocky, scratch或python） 'shortLink': str, # 分享链接 'theme': str, # 作品主题 'subTheme': str, # 作品发布主题 'iframeUrl': str, # 作品iframe地址 'scratchFile': str, # scratch作品文件url 'codeType': str, # 代码类型 'firstPopups': bool , # 是否在作品发布者点进该作品后显示弹窗 'forkAuthorizationStatus': bool, # 是否允许他人fork 'isFirstPublish': bool, # 是否为首次发布 'haveReported': bool # 是否已举报 } 使用IcodeAPI.getWorkSubmitInfo方法获取一个作品在发布时向后台提交的数据。（与IcodeAPI.submitWork方法发送的数据几乎相同）。 def getWorkSubmitInfo(self, workId : str) -> dict 返回的字典格式通常如下： { 'avatar': str, # 作者头像url 'category': str, # 不明意义 'codeType': str, # 代码类型 'commit': str, # 提交时间 'createtime': str, # 创建时间 'description': str, # 作品简介 'fork': int, # 是否允许fork 'forkcommit': str, # 不明意义 'forkfrom': str, # 从哪里fork（一个workId） 'likes': int, # 点赞数 'owner': str, # 不明意义 'publish': int, # 是否公开（1为不公开，2为公开） 'qrCodeImage': str, # 作品二维码图片url 'shareMessage': str, # 分享信息 'shareText': str, # 分享文本 'shareTitle': str, # 分享标题 'subtheme': str, # 发布主题 'theme': str, # 主题 'thumbnail': str, # 封面url 'thumbnailList': list, # 封面列表 'title': str, # 标题 'username': str, # 作者名 'visits': int, # 浏览量 'workid': str # 作品id } 获取更多作品 使用IcodeAPI.getMoreWorks方法获取更多作品。 def getMoreWorks(self, userId : str = None, workId : str = None) -> list 参数userId和workId都是可选的，如果同时提供，则以userId为准。参数userId为用户id。参数workId为作品id。 如果只填入了workId，那么将会自动使用self.getWorkDetail方法获取作品发布者id。 返回的字典格式通常如下： [ { 'id': str, # 作品id 'title': str, # 作品标题 'imgUrl': str, # 作品封面url 'likeNum': int, # 作品点赞数 'browseNum': int, # 作品浏览数 'userName': str, # 发布者用户名 'userImage': str # 发布者头像url } # 列表中可以同时存在多个元素，表示有多个作品。 ] 使用IcodeAPI.getWorks方法获取社区中的所有作品。IcodeAPI.getWorks提供了检索方式。 def getWorks(self, page : int = 1, getNum : int = 20, sortType : int = 2, theme : str = 'all', codeLanguage : str = 'all', keyword : Union[str, any] = '') -> list 参数page为页码，默认为1。参数getNum为每页的作品数量，默认为20。参数sortType为排序方式，默认为2。1为按点赞量从大到小排序，2则为按发布时间从现在往以前排序。参数theme为作品类型，默认为all，即所有类型。可以为all , play , story , art , minecraft , scratch , turtle。参数codeLanguage为代码语言，默认为all，即所有语言。可以为all , blockly , scratch , python。参数keyword为获取到作品的检索关键词，默认为空。 返回的字典格式通常如下： [ { 'id': str, # 作品id 'title': str, # 作品标题 'imgUrl': str, # 作品封面url 'userId': str, # 作品发布者id 'browseNum': int, # 作品浏览量 'userName': str, # 作品发布者用户名 'userImage': str, # 作品发布者头像url 'codeLanguage': str # 作品语言类型 } ] 使用IcodeAPI.getMyWorks方法获取当前登录账号的所有作品。它和IcodeAPI.getWorks一样提供检索方式，并且可以获取未发布的作品。 def getMyWorks( self, page : int = 1, getNum : int = 20, theme : str = 'all', codeLanguage : str = 'all', status : int = 2, keyword : Union[str, any] = '') -> list 参数page为页码，默认为1。参数getNum为每页的作品数量，默认为20。参数theme为作品类型，默认为all，即所有类型。可以为all , play , story , art , minecraft , scratch , turtle。参数codeLanguage为代码语言，默认为all，即所有语言。可以为all , blockly , scratch , python。参数status为作品状态，默认为2，即所有状态。可以为1或2。1为未发布，2为已发布。参数keyword为获取到作品的检索关键词，默认为空。 返回的字典格式通常如下： [ { 'id': str, # 作品id 'title': str, # 作品标题 'imgUrl': str, # 作品封面url 'status': int, # 作品发布状态 'userId': str, # 作品发布者id 'likeNum': int, # 作品点赞量 'browseNum': int, # 作品浏览量 'enshrineNum': int, # 作品收藏量 'forkNum': int, # 作品被改编量 'userName': str, # 作品发布者用户名 'userImage': str, # 作品发布者头像url 'codeLanguage': str, # 作品语言类型 'theme': str, # 作品类型 'subTheme': str # 作品发布类型 } ] 获取作品评论 使用IcodeAPI.getWorkComments方法获取作品的所有评论。 def getWorkComments(self, workId : str, page : int = 1, getNum : int = 20) -> list 参数workId为作品id。参数page为页码，默认为1。 参数getNum为每页的评论数量，默认为20。 返回的字典格式通常如下： [ { 'id': int, # 作品评论id 'content': str, # 作品评论内容 'userId': str, # 作品评论发布者id 'name': str, # 作品评论发布者用户名 'image': str, # 作品评论发布者头像url 'isAuthor': bool, # 是否为作者 'praiseNum': int, # 作品评论点赞量 'replyNum': int, # 作品评论回复量 'time': int, # 作品评论发布时间 'hasPraised': bool # 是否被当前登录的账户点赞 } ] 获取Scratch作品内部资源 我们都知道，Scratch作品内部可以包含很多资源，例如图片、音乐等。它们在Scratch中被称为“asset”。每个asset有一个自己的md5ext属性，是由文件内容由MD5哈希加密和文件后缀组合而来的。md5ext属性可以在project.json等Scratch源代码文件中找到。使用IcodeAPI.getScratchAsset方法可以获取一个在小图灵服务器中指定md5ext属性的asset文件。 def getScratchAsset(self, md5ext : str) -> bytes 参数md5ext为asset文件的md5ext属性。 该方法以二进制(bytes)形式返回asset文件的内容。可以直接使用返回值进行文件读写等操作。需要注意的是，如果获取的asset文件类型为svg文件，那么需要将返回值解码。例如： from icodeapi import IcodeAPI cookie = input('请输入cookie: ') api = IcodeAPI(cookie = cookie) # 构建用户对象 # 获取mp3类型 asset文件 with open(\"Everyday World.mp3\", 'wb') as fb: content = api.getScratchAsset('119eab65876ab93a229d1a339238db39.mp3') # 获取文件内容 fb.write(content) # 写入 # 获取svg类型 asset文件 with open('testsvg.svg', 'w', encoding = 'utf-8') as f: content = api.getScratchAsset('71b09db63e151c30d92b16181520bb29.svg') # 获取文件内容 f.write(content.decode('utf-8')) # 解码内容并写入 代码运行完毕后，svg文件可以被正确地查看，mp3文件可以被正常播放。如果想了解更多关于Scratch Json的内容，另行参阅： Json - Scratch WikiScratch File Format - Scratch WikiScratch3 Static Assets API "},"GetPersonInfo.html":{"url":"GetPersonInfo.html","title":"获取用户","keywords":"","body":"获取用户信息 使用getUserIdFromUrl函数从url中获取用户id。 def getUserIdFromUrl(url : str) -> str url ： 用户主页的url 示例： from icodeapi import getUserIdFromUrl url = 'https://icodeshequ.youdao.com/personal?userId=wxoXQUDj60yxZP7JXZiBRSvJ-SeFf8' print(getUserIdFromUrl(url)) wxoXQUDj60yxZP7JXZiBRSvJ-SeFf8 使用IcodeAPI.getPersonInfo方法获取一个用户的基础信息。 def getPersonInfo(self, userId : str) -> dict userId ： 用户id 方法的返回值通常格式如下: { 'worksNum': int, # 作品数量 'viewNum': int, # 浏览量 'praiseNum': int, # 点赞量 'enshrinesNum': int, # 收藏量 'forkNum': int, # 被改编量 'userId': str, # 用户id 'img': str, # 用户头像 'nickName': str, # 用户昵称 'intro': str # 用户简介 } 使用IcodeAPI.getPersonWorks获取用户作品信息。 def getPersonWorks(self, userId : str, page : int = 1, getNum : int = 20) -> list userId ： 用户idpage ： 获取的页数量getNum ： 一页里包含的作品数量 方法的返回值通常格式如下: [ { 'id': str, # 作品ID 'title': str, # 作品标题 'imgUrl': str, # 作品封面图片URL 'status': int, # 作品状态（1：已发布，2：已取消发布） 'likeNum': int, # 点赞数 'browseNum': int, # 浏览次数 'enshrineNum': int, # 收藏数 'forkNum': int, # 改编数 'userName': str, # 用户名 'userImage': str, # 用户头像图片URL 'codeLanguage': str, # 代码语言（'scratch' 或 'python'） 'theme': str, # 主题 'subTheme': str # 子主题 } ] 使用IcodeAPI.getPersonEnshrines获取用户收藏信息。 def getPersonEnshrines(self, userId : str, page : int = 1, getNum : int = 20) -> list userId ： 用户idpage ： 获取的页数量getNum ： 一页里包含的作品数量 方法的返回值通常格式如下: [ { 'id': str, # 作品ID 'title': str, # 作品标题 'imgUrl': str, # 作品封面图片URL 'userId': str, # 发布者userId 'status': int, # 作品状态（1：已发布，2：已取消发布） 'likeNum': int, # 点赞数 'browseNum': int, # 浏览次数 'userName': str, # 用户名 'userImage': str, # 用户头像图片URL 'codeLanguage': str, # 代码语言（'scratch' 或 'python'） 'theme': str, # 主题 'subTheme': str # 子主题 } ] "},"DoSomething.html":{"url":"DoSomething.html","title":"做些什么","keywords":"","body":"进行一些操作。 这些操作均需要登录，如果IcodeAPI或AsyncIcodeAPI对象没有登录，执行这些操作将抛出LoginError异常。 对作品操作 *使用IcodeAPI.comment方法进行评论。 def comment(self, workId : str, content : str) -> dict workId ： 作品idcontent ： 评论内容 注意，评论操作有5秒的时间限制。使用IcodeAPI.like方法对一个作品进行点赞。 def like(self, workId : str, mode : int = 1) -> dict workId ： 作品idmode : 1为点赞，2为取消点赞 注意，点赞操作有3秒的时间限制。使用IcodeAPI.enshrine方法对一个作品进行收藏。 def enshrine(self, workId : str, mode : int = 1) -> dict workId ： 作品idmode : 1为收藏，2为取消收藏 使用IcodeAPI.report方法对一个作品进行举报。 def report(self, workId : str, reason : str, reportType : int) -> dict workId ： 作品idreason ： 举报原因reportType ： 举报类型，1：抄袭，2：商业广告，3：人身攻击，4：违法违规，5：未成年人不宜 使用IcodeAPI.submitWork发布一个作品。 def submitWork(self, workCode : str = '', workType : str = 'Scratch', publish : int = 1, save : int = False, title : str = 'Scratch Project', description : str = 'Project Description', thumbnail : str = 'http://ydschool-online.nosdn.127.net/svg/0c3a986d5266bd5a186014aebd219e05c9696de777dea2b5dfe658dc661e572c.png', fork : int = 0, workDetail : tuple = None, workId : str = None) -> dict workCode ： 作品代码，Scratch作品需要传入json数据workType ： 作品类型，'Scratch'为Scratch，'Python'为Python，开头字符不区分大小写publish ： 发布状态，1为发布，2为不发布save ： 保存状态title ： 作品标题description ： 作品描述thumbnail ： 作品封面urlfork ： 作品是否允许改编，0为不允许，1为允许workDetail ： 传入这个参数可以自动读取数据并发布作品，要求一个元组，第一个元素是IcodeAPI.getWorkDetail的返回值，第二个元素是IcodeAPI.getWorkSubmitInfo的返回值workId : 如果传入这个参数将会重新发布作品id为这个参数的作品 原英文注释： ''' Submit a work. This function only supported to submit Scratch or Python work, no Blockly. If the workId isnt None, the function will reSubmit the work. When the workType is Python, and the save is true, the funciton will only save the work, not publish the work. If publish = 1, the function will publish the work, when it is 2, the fucntion will unpublish the work. If fork = 1, allow others to fork your work, if fork = 0, dont allow others to fork your work. If workDetail should be a tuple. workDetail[0] = `getWorkDetail()` return value, workDetail[1] = `getWorkSubmitInfo()` return value. ''' 大义：这个方法可以发布scratch或Python作品，但不支持发布Blockly作品。如果workId不为None，则重新发布workId为workId的作品。当workType为Python，且save为True时，函数只会保存作品，而不会发布作品。当publish = 1时，函数会发布作品，当publish = 2时，函数不会发布作品。当fork = 1时，允许其他人 fork 你的作品，当fork = 0时，不允许其他人 fork 你的作品。当workDetail为元组时，必须有以下格式：workDetail[0] = getWorkDetail()返回值，workDetail[1] = getWorkSubmitInfo()返回值，方法内部会自动读取数据并发布作品。示例： from icodeapi import IcodeAPI COOKIE = input('Enter cookie: ') user = IcodeAPI(cookie = COOKIE) info = user.submitWork('print(\"Hello IcodeAPI\")', 'python', save = True, title = 'Hello IcodeAPI', description = 'save by icodeapi' ) print(info) workId = info.get('data') info = user.submitWork(workDetail = (user.getWorkDetail(workId), user.getWorkSubmitInfo(workId))) print(info) 输出： { 'code': 0, 'msg': 'success', 'data': '0', 'user': { 'userId': 'qqCD6566A4CF1F39111AE5246D138220CA', 'name': 'qqcd', 'image': 'https://oimageb6.ydstatic.com/image?id=6039990957530368796&product=xue&format=PNG' } } { 'code': 0, 'msg': 'success', 'data': '70e527af8b5949049bf0ebf0da0b5998', 'user': { 'userId': 'qqCD6566A4CF1F39111AE5246D138220CA', 'name': 'qqcd', 'image': 'https://oimageb6.ydstatic.com/image?id=6039990957530368796&product=xue&format=PNG' } } 使用IcodeAPI.deleteWork方法删除一个作品。 def deleteWork(self, workId : str) -> dict workId : 需要删除的作品id 社交性操作 使用IcodeAPI.updateIntro方法对个人简介进行修改 def updateIntro(self, intro : str = 'IcodeAPI...') intro : 新的简介，默认为'IcodeAPI...' 使用IcodeAPI.reply方法回复一条评论 def reply(self, content : str, commentId : int, replyId : int = None) -> dict content : 回复内容commentId : 要回复的评论idreplyId : 要回复的回复id，默认为None 该方法可以给一个评论回复，也可以给一个评论的回复回复。使用IcodeAPI.deleteComment方法删除一条评论 def deleteComment(self, commentId : int = None, replyId : int = None) -> dict commentId : 要删除的评论id，默认为NonereplyId : 要删除的回复id，默认为None 这个方法可以删除一条评论或一条回复。使用IcodeAPI.getReplies方法回去一条评论包含的回复。 def getReplies(self, commentId : int, page : int = 1, getNum : int = 20) -> list commentId : 要获取回复的评论idpage : 获取回复的页数，默认为1getNum : 获取的回复数量，默认为20 当获取的是一个评论的所有回复时，返回值通常有如下格式： [ # When this reply is a reply to a comment { \"id\": str, # 回复的id \"content\": str, # 回复的内容 \"type\": int, # 回复的类型 \"commentId\": int, # 回复的评论id \"userId\": str, # 发布者的userId \"name\": str, # 发布者的昵称 \"image\": str, # 发布者的头像 \"isAuthor\": bool, # 是否为作者发布的回复 \"time\": int, # 回复的时间 \"praiseNum\": int, # 点赞数 \"hasPraised\": bool # 当前账号是否点赞了 } ] 当获取的是某一条回复的所有回复时，返回值通常有如下格式： [ # When this reply is a reply to an another reply { \"id\": int, # 回复的id \"content\": str, # 回复的内容 \"type\": int, # 回复的类型 \"commentId\": str, # 回复的评论id \"userId\": str, # 发布者的userId \"name\": str, # 发布者的昵称 \"image\": str, # 发布者的头像 \"isAuthor\": bool, # 是否为作者发布的回复 \"replyUserId\": str, # 回复的发布者userId \"replyName\": str, # 回复的发布者昵称 \"replyImage\": str, # 回复的发布者头像 \"time\": int, # 回复的时间 \"praiseNum\": int, # 点赞数 \"hasPraised\": bool # 当前账号是否点赞了 } ] 使用IcodeAPI.getMessages方法获取用户消息中心里推送的消息。 def getMessages(self, messageType : str = 'reply', page : int = 1, getNum : int = 20) -> list messageType : 获取的消息类型，默认为回复消息，可选的有reply、enshrine、systempage : 获取消息的页数，默认为1getNum : 获取的消息数量，默认为20 返回值通常有以下格式： [ { 'actionUserId': str, # 消息发出者的userId 'actionUserImage': str, # 消息发布者的图片 'actionUserName': str, # 消息发布者的昵称 'createTime': str, # 消息发布时间 'createTimeStr': str, # 消息发布时间 'haveRead': bool, # 是否已读 'id': int, # 消息的id 'content' : str, # 消息的内容 'type': int, # 消息的类型 'worksId': str, # 消息所属的作品的id 'worksTitle': str # 消息所属的作品的标题 } ] 使用IcodeAPI.deleteMessage方法删除一条消息。 def deleteMessage(self, messageId : int) -> dict messageId : 要删除的消息的ID 使用IcodeAPI.praiseComment方法对一条评论或者一条回复点赞。 def praiseComment(self, commentId : int = None, replyId : int = None, mode : int = 1) -> dict commentId : 评论的IDreplyId : 回复的IDmode : 点赞的模式，默认为1即点赞，当为2时取消点赞 使用IcodeAPI.readMessage方法将一条消息设为已读。 def readMessage(self, messageId : int) -> dict messageId : 要设为已读的消息的ID 使用IcodeAPI.readAllMessages方法将所有消息设为已读。 def readAllMessages(self, tab : int = 1) -> dict tab : 消息的类型，默认为1即所有评论消息，当为2时所有收藏消息，当3为所有系统消息 文件床操作 使用IcodeAPI.uploadFile方法上传一个文件到小图灵文件床。 def uploadFile(self, name : str, suffix : str, file : bytes | str) -> dict name : 文件名suffix : 文件后缀名file : 文件内容 注意，小图灵文件床只支持Scratch支持上传的asset文件类型，如mp3, svg等。示例： from icodeapi import IcodeAPI COOKIE = input('Enter cookie: ') user = IcodeAPI(cookie = COOKIE) with open(r'.\\testing.svg', 'r', encoding = 'utf-8') as f: svg = f.read() print(user.uploadFile('testing', 'svg', svg)) 输出： {'code': '200', 'message': '上传成功', 'data': { 'bucketName': 'ydschool-online', 'key': 'svg/testing.svg', 'versionId': None, 'etag': '5140647a773acf048add0f98bb82f666' } } "},"AsyncSupport.html":{"url":"AsyncSupport.html","title":"异步支持","keywords":"","body":"异步支持 与TuringAPI的异步支持不同，icodeapi弃用了繁琐的三层异步模型（turingAPI.task, turingAPI.event, turingAPI.eventPool），而是提供了一个AsyncIcodeAPI类，包含的均为异步方法。AsyncIcodeAPI和IcodeAPI类的API没有多大变更，基本上可以套IcodeAPI的方法调用方式。但是有少许不同。 登录账号 AsyncIcodeAPI在实例化后需要手动登录。且为了防止一些不必要的坏事发生，需要手动关闭连接池。 import asyncio from icodeapi import AsyncIcodeAPI # 获取用户输入的cookie COOKIE : str = input('Enter cookie: ') # 实例化AsyncIcodeAPI对象 user : AsyncIcodeAPI = AsyncIcodeAPI(cookie=COOKIE) # 定义一个异步函数，用于登录和获取用户信息 async def main(api: AsyncIcodeAPI): # 登录 await api.login() print(api.getInfo()) # 关闭连接池 await api.closeClient() asyncio.run(main(user)) 示例 构建fastapi服务器。 from fastapi import FastAPI from fastapi.responses import JSONResponse from fastapi.middleware.cors import CORSMiddleware from icodeapi import AsyncIcodeAPI import uvicorn app : FastAPI = FastAPI() # 创建fastapi实例 app.add_middleware( CORSMiddleware, allow_origins=['*'], allow_credentials = True, allow_methods=['*'], allow_headers=['*'], ) api : AsyncIcodeAPI = AsyncIcodeAPI() # 实例化AsyncIcodeAPI @app.get(\"/\") async def getWork() -> JSONResponse: # 返回作品集 results = await api.getWorks() return JSONResponse(results) @app.get(\"/{workId}\") async def getWorkById(workId : str) -> JSONResponse: # 返回作品信息 results = await api.getWorkDetail(workId) return JSONResponse(results) @app.get(\"/person/{userId}\") async def getPerson(userId : str) -> JSONResponse: # 返回个人信息 results = await api.getPersonInfo(userId) return JSONResponse(results) uvicorn.run(app, host = \"0.0.0.0\", port = 80) "},"Tools.html":{"url":"Tools.html","title":"工具模块","keywords":"","body":"工具模块 icodeapi提供了一个tools模块，里面包含了一些强大而实用的工具函数。 下载作品 使用tools.DownloadWork函数异步地下载一个作品。 async def DownloadWork(workId : str, path : str, api : AsyncIcodeAPI = None) workId : 需要下载的作品idpath : 下载后保存的路径api : 发出请求时使用的AsyncIcodeAPI对象，当为None时默认新创建一个 刷浏览量 使用tools.ViewNumMaker函数快速提升一个作品的浏览量。如果浏览量在一日内提高的数值非常高，有大概率会登上社区首页推荐。 async def ViewNumMaker(workId : str, num : int = 5000, api : AsyncIcodeAPI = None) workId : 需要刷浏览量的作品idnum : 需要刷的浏览量api : 发出请求时使用的AsyncIcodeAPI对象，当为None时默认新创建一个 评论区唱歌 使用tools.SingSong函数在评论区循环发送字符串内所有内容。 def SingSong(workId : str, songWords : str, api : IcodeAPI) workId : 需要评论的作品idsongWords : 需要发送的内容，用换行分隔每一句话api : 发出请求时使用的IcodeAPI对象 该函数会返回一个生成器，每迭代一次发送一句内容。请注意评论操作的时间间隔限制，小图灵社区设置了5秒才能评论一次的限制。示例： from icodeapi import * from icodeapi.tools import * import time user = IcodeAPI(input('Cookie: ')) times = int(input('Sing times: ')) num = 0 while num Without You by Avicii 删除评论 使用tools.CommentsCleaner方法批量删除一个作品内的评论。 async def CommentsCleaner(workId : str, api : AsyncIcodeAPI, page : Union[list[int], tuple[int], set[int]] = ALL_PAGES, getNum : int = 20) -> bool workId : 要删除评论的作品IDapi : 发出请求时使用的AsyncIcodeAPI对象page : 要删除的评论页码，如果为tools.ALL_PAGES则删除所有页getNum : 每次获取的评论数量，默认为20 "},"Server.html":{"url":"Server.html","title":"构建服务器","keywords":"","body":"构建服务器 如果您想让您的账号在社区上充当一个机器人的角色，那么server模块就是专门为你而开发。icodeapi提供了server模块以构建有道小图灵的账号机器人，可以做到监视某些数据并执行回调函数。 该模块在1.0.3版本被加入。 登录 使用server.IcodeServer类构建一个服务器。 class IcodeServer: __api : AsyncIcodeAPI __events : list[Awaitable] __tocomment : list[Awaitable] __tolike : list[Awaitable] debug : bool running : bool ban : set[str] results : list[list[list]] def __init__(self, api : AsyncIcodeAPI, ban : set[str] = set()): self.__api = api self.__events = [] self.__tocomment = [] self.__tolike = [] self.ban = ban self.running = False self.debug = True self.results = [] __api : 服务器发出请求使用的AsyncIcodeAPI对象 __events : 服务器需要监听的事件列表 __tocomment : 服务器需要进行执行的评论操作列表 __tolike : 服务器需要进行执行的点赞操作列表 ban : 服务器操作黑名单集合 debug : 服务器是否开启调试模式 running : 服务器是否正在运行 results : 服务器运行结果列表 __events, __tocomment, __toloke三个私有属性是及其低级的属性，请使用更高级的api，而不是直接使用它们。示例 from icodeapi import server from icodeapi import AsyncIcodeAPI api = AsyncIcodeAPI(input()) # 实例化用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 SERVER.debug = False # 关闭debug模式 @SERVER.CheckMessage() # 注册新的监听事件 def checkmessage(content : str) -> None: print('New Message: ', content) server.RunServer(server = SERVER) # 运行服务器 这段代码会监测任何消息中心中的新消息，一旦有新消息就回调checkmessage。注意:在运行这段示例代码时，如果用相同的账号给自己评论，不会输出任何内容。因为IcodeServer自动将自己加入黑名单。 运行服务器 如果想要开始监听所有已注册事件，可以使用server.RunServer函数。 def RunServer(server : IcodeServer) -> None server : 需要运行的服务器对象 在server.IcodeServer中也提供了一个异步的运行方法。 async def run(self) 但在运行前，需要对服务器对象进行登录，在运行结束后，需要关闭服务器。而server.RunServer会自动执行这些操作，这也是serevr.RunServer的便捷之处。示例： from icodeapi import server from icodeapi import AsyncIcodeAPI import asyncio api = AsyncIcodeAPI(input()) # 实例化用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 SERVER.debug = False # 关闭服务器调试模式 @SERVER.CheckMessage() # 注册新的监听事件 def checkmessage(content : str) -> None: print('New Message: ', content) async def main(Server : server.IcodeServer) -> None: # 主程序 await Server.login() # 登录 await Server.run() # 开始监听 await Server.closeBot() # 关闭服务器 asyncio.run(main(SERVER)) # 主程序最高级入口 停止服务器运行 在运行服务器后，服务器对象的running属性将为True，如果想要停止服务器运行，可以将其设为False或任何为假的值。在设置后服务器不会立即停止，而是完成最后一次迭代后退出运行状态。也可以在终端使用ctrl + c快捷键（Windows操作系统）终止服务器运行。在服务器结束运行后可以使用results属性查看运行的总结果。 注册监听事件 在服务器运行前可以使用装饰器注册需要监听的事件。监听消息中心使用server.IcodeServer.CheckMessage方法注册新的消息中心监听事件。 def CheckMessage(self, workList : list[str] | None = None, checkFunc : Callable[[str, str], bool] = (lambda x, y : True), autoRead : bool = True, checkRead : bool = True, checkNum : int = 30, name : any = None ) workList : 只监测在这个列表中的作品的消息，如果为None则不进行过滤checkFunc : 消息检测函数，返回真则进行处理，否则不进行处理。方法内部会给这个函数传入两个参数，第一个为消息内容，第二个为消息发送者的userIdautoRead : 是否在处理完检测到的消息后自动将其设为已读checkRead : 是否只检测未读的消息checkNum : 检测消息的条数，如果超过这个数值则不进行处理name : 给这个监听事件命名，方便调试 示例： from icodeapi import server from icodeapi import AsyncIcodeAPI api = AsyncIcodeAPI(input()) # 实例化用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 SERVER.debug = False # 关闭debug模式 @SERVER.CheckMessage(checkFunc = (lambda x, y : x == '你真帅'), checkNum = 50) # 注册新的监听事件 def checkmessage(userId : str) -> None: print('又有一个人夸你帅，这个人是', userId) server.RunServer(server = SERVER) # 运行服务器 装饰器传入的回调函数可以包含四个参数，server.IcodeServer.CheckMessage会自动读取参数列表并传入对应信息： content : 检测到的信息内容userId : 检测到的信息发送者的userIdapi : server.IcodeServer的__api属性bot : 服务器对象本身 新的监听事件注册完毕后，CheckMessage生成的新的监听函数一般会返回: [ # First call { \"code\": 0, \"msg\": \"success\", \"user\": { \"userId\": \"xxx\", \"name\": \"xxx\", \"image\": \"xxx\", \"mobile\": \"xxx\" } }, # Function's return # Second call { \"code\": 0, \"msg\": \"success\", \"user\": { \"userId\": \"xxx\", \"name\": \"xxx\", \"image\": \"xxx\", \"mobile\": \"xxx\" } }, # Function's return , # Function Object 'Enshrine work1' # Function's name ] 包含所有消息的回调函数的返回值，和CheckMessage方法本身以及CheckMessage在注册时传入的name参数。该数据会加入server.IcodeServer的results属性。 监听单个作品信息使用server.IcodeServer.CheckWork注册单个作品数据的监听事件。 def CheckWork(self, workId : str, addBrowseNum : bool = False, checkFunc : Callable | None = (lambda **kwargs : bool(kwargs)), name : str = None) workId : 作品idaddBrowseNum : 在监视数据时是否增加浏览量（AsyncIcodeAPI.getWorkDetail的缘由）checkFunc : 检测函数，当返回真时才会触发回调函数。方法内部会按照装饰器传入的函数的参数给这个参数传入同样的参数。name : 给这个监听事件命名，方便调试 装饰器传入的回调函数可以包含6个参数，如下所示： detail : 使用AsyncIcodeAPI.getWorkDetail获取到该作品的信息submitInfo : 使用AsyncIcodeAPI.getWorkSubmitInfo获取到该作品的提交信息comments : 使用AsyncIcodeAPI.getWorkComments获取到该作品的评论信息moreWorks : 使用AsyncIcodeAPI.getMoreWorks获取到该作品的更多作品信息api : 该服务器对象的__api属性bot : 该服务器对象本身 示例： from icodeapi import server from icodeapi import AsyncIcodeAPI api = AsyncIcodeAPI(input()) # 实例化用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 SERVER.debug = False # 关闭debug模式 @SERVER.CheckWork('a1f09b5eb34a48dfbdc8dee59d130ec6', # 注册监听事件 checkFunc = (lambda **info : info.get('detail').get('likeNum')>16)) # 检测点赞量 def stop(detail : dict, bot : server.IcodeServer): print('16赞达成') bot.running = False # 停止服务器运行 server.RunServer(server = SERVER) # 运行服务器 该方法的返回值和server.IcodeServer.CheckMessage大致相同，也会加入server.IcodeServer.results。 监听单个用户信息使用server.IcodeServer.CheckPerson注册单个用户的监听事件。 def CheckPerson(self, userId : str, checkFunc : Callable | None = (lambda **kwargs : True), name : str | None = None) userId : 用户idcheckFunc : 检测函数，当返回真时才会触发回调函数。方法内部会按照装饰器传入的函数的参数给这个参数传入同样的参数。name : 给这个监听事件命名，方便调试 装饰器传入的回调函数可以包含5个参数，如下所示： info : 使用AsyncIcodeAPI.getPersonInfo获取到该用户的信息works : 使用AsyncIcodeAPI.getPersonWorks获取到该用户的所有作品信息enshrines : 使用AsyncIcodeAPI.getPersonEnshrines获取到该用户的收藏作品信息api : 该服务器对象的__api属性bot : 该服务器对象本身 示例： from icodeapi import server from icodeapi import AsyncIcodeAPI api = AsyncIcodeAPI(input()) # 实例化用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 SERVER.debug = False # 关闭debug模式 @SERVER.CheckPerson('qqB60D8500058F9FBEA41D76E17167C37A', # 注册新的监听事件 checkFunc = (lambda **info : info.get('info').get('enshrinesNum')>122)) # 检测收藏量 def getInfo(info : dict, bot : server.IcodeServer): print('目标达成，目前收藏量：') print(info.get('enshrinesNum')) bot.running = False # 结束服务器运行 server.RunServer(server = SERVER) # 运行服务器 该方法的返回值和server.IcodeServer.CheckMessage大致相同，也会加入server.IcodeServer.results。 取消监听事件 可以使用server.IcodeServer.cancel方法取消一个监听事件。 def cancel(self, func : Callable) -> None 示例： from icodeapi import server from icodeapi import AsyncIcodeAPI api = AsyncIcodeAPI(input()) # 实例化用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 @SERVER.CheckMessage() # 注册新的监听事件 async def getInfo(userId : str, api : AsyncIcodeAPI): work = await api.getPersonWorks(userId, 1, 1) await api.enshrine(work[0]['id']) SERVER.cancel(getInfo) # 取消 server.RunServer(server = SERVER) # 运行服务器 在运行服务器后，服务器也不会监听消息中心。 异步的回调函数，评论、点赞阻塞管理和fastReply 当需要进行一些耗时较长的IO操作时，同步的回调函数是不能满足需求的，这时候就需要使用异步的回调函数。示例： from icodeapi import server from icodeapi import AsyncIcodeAPI api = AsyncIcodeAPI(input()) # 实例化用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 @SERVER.CheckMessage() # 注册新的监听事件 async def getInfo(userId : str, api : AsyncIcodeAPI): # 获取AsyncIcodeAPI对象 work = await api.getPersonWorks(userId, 1, 1) # 获取作品 await api.enshrine(work[0]['id']) # 收藏 server.RunServer(server = SERVER) # 运行服务器 这段代码可以自动收藏来评论的人的作品。评论、点赞阻塞管理当我们在回调函数中使用api参数来进行对某个用户评论或点赞时，会出现风险。因为社区给评论和点赞设置了时间限制，分别为5秒和3秒内只能进行一次评论和点赞操作。而评论、点赞的操作是异步的，这就代表在一个操作进行完成后不需要等待5或3秒下一个操作就会立即执行（因为它们都已被注册到asyncio事件循环中），这会导致很多操作出现因操作频繁请求被拦截的错误。为了解决这个问题，server.IcodeServer提供了comment, reply和like方法来代替AsyncIcodeAPI的comment, reply和like方法。而且这些方法是同步的。这些方法和AsyncIcodeAPI的comment, reply和like方法的调用方式完全一样，参数设置完全相同。当调用这些方法后，server.IcodeServer将把需要进行的操作放入一个等待序列中，在服务器处于运行中状态时，将由两个内部的协程将它们有序地执行，并且设置阻塞时间，当阻塞时间到达时，将自动执行下一个操作。这样就不会引发因操作频繁请求被拦截的错误。示例： from icodeapi import server from icodeapi import AsyncIcodeAPI api = AsyncIcodeAPI(input()) # 实例化用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 @SERVER.CheckMessage() # 注册新的监听事件 async def getInfo(userId : str, api : AsyncIcodeAPI, bot : server.IcodeServer): work = await api.getPersonWorks(userId, getNum = 1) bot.comment(work[0]['id'], 'test') # 调用评论方法 server.RunServer(server = SERVER) # 运行服务器 另外，server.IcodeServer还提供了异步方法fastReply来快速在一个用户的第一个作品下评论一条内容。这样省去了一次获取用户作品的操作，简化了代码。 async def fastReply(self, userId : str, content : str) -> None 示例： from icodeapi import server from icodeapi import AsyncIcodeAPI api = AsyncIcodeAPI(input()) # 实例化用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 @SERVER.CheckMessage() # 注册新的监听事件 async def getInfo(userId : str, bot : server.IcodeServer): await bot.fastReply(userId, \"hello world\") # 快速回复 server.RunServer(server = SERVER) # 运行服务器 服务器池 如果想要多个账户同时监听数据，可以使用服务器池server.ServerPool。 class ServerPool: __servers : list def __init__(self, *servers : IcodeServer): self.__servers = servers __servers : 一个包含所有服务器对象server.IcodeServer的列表 当初始化时传入一个服务器对象列表（需要作为可变参数形式）即可初始化服务器池。server.ServerPool.login会自动将池内的所有服务器对象进行登录。 async def login(self) 可以使用server.ServerPool.addAPI和server.ServerPoool.addServers方法把多个AsyncIcodeAPI对象或多个IcodeServer对象添加到池中。如果加入的是AsyncIcodeAPI对象，则会自动生成新的IcodeServer对象并将AsyncIcodeAPI对象填入。api和servers的序列需要作为可变参数形式。 async def addAPI(self, * api : AsyncIcodeAPI) async def addServers(self, * servers : IcodeServer) 使用server.ServerPool.RunServers和server.ServerPool.stopRunning来运行所有服务器和停止所有服务器。使用server.ServerPool.closePool来停止所有服务器的运行并关闭服务器池。示例： from icodeapi import server from icodeapi import AsyncIcodeAPI import asyncio api = AsyncIcodeAPI(input()) # 实例化用户对象 api2 = AsyncIcodeAPI(input()) # 实例化第二个用户对象 SERVER = server.IcodeServer(api = api) # 实例化服务器 SERVER2 = server.IcodeServer(api = api2) # 实例化第二个服务器 @SERVER.CheckMessage() # 注册新的监听事件 async def getInfo(userId : str, bot : server.IcodeServer): await bot.fastReply(userId, \"hello world\") # 快速回复 @SERVER2.CheckMessage() # 注册新的监听事件 async def getInfo2(userId : str, bot : server.IcodeServer): await bot.fastReply(userId, \"world hello\") # 快速回复 pool = server.ServerPool(*[SERVER, SERVER2]) # 创建池 async def main(pool : server.ServerPool): # 主程序 await pool.login() # 登录 await pool.RunServers() # 开始全部运行 await pool.closePool() # 关闭池 asyncio.run(main(pool)) 目前server.ServerPool还存在一些问题，会在将来的版本修复。 "},"Updates.html":{"url":"Updates.html","title":"更新日志","keywords":"","body":"历代版本更新日志 alpha 0.1 2023.8.21 增加IcodeAPI类添加api alpha 0.2 增加api添加了参数错误报错 alpha 0.3 增加2个api将IcodeAPI.getInfo改为IcodeAPI.login优化了一些内容 alpha 0.3.1 修复bug加了一个api alpha 0.4 增加了2个api增加了用户登录警告和未登录报错优化了getWorkIdFromUrl方法添加了IcodeAPI.loginStatus成员修改了IcodeAPI.info成员的内容 alpha 0.5 增加了3个api alpha 0.6 增加了2个api修复了IcodeAPI.getWorkComments的bug优化了一些内容 beta 0.1 增加AsyncIcodeAPI类,作为IcodeAPI的派生类不再使用aiohttp,改用httpx实现对异步的支持优化了一些内容 beta 0.2 完成所有异步API移除了IcodeAPI.headers增加LoginWarning增加一个api beta 0.3 将IcodeAPI的urllib3Client更换为httpxClient,全面开始使用httpx连接池修复了4~5个大大小小的bug添加了IcodeAPI.readAllMessages的注释添加IcodeAPI.submitWork和AsyncIcodeAPI.submitWork的fork参数优化部分代码 v1.0.0 添加IcodeAPI.__init__和AsyncIcodeAPI.__init__的timeout参数增加IcodeAPI.getScratchAsset和AsyncIcodeAPI.getScratchAsset函数以获取scratch作品资源增加getUserIdFromUrl函数增加icodeapi.tools模块封装一些实用工具修复3~4个bug,给IcodeAPI.submitWork和AsyncIcodeAPI.submitWork添加workDetail参数,添加workCode参数默认值,且workType现在允许\"scratch\"和\"python\"这样的写法给IcodeAPI.getWorkDetail和AsyncIcodeAPI.getWorkDetail增加了addBrowseNum参数,优化了部分代码 v1.0.1 给tools模块增加了CommentsCleaner方法,用于异步清理评论改进tools模块的DownloadWork方法,现在它可以下载codeLanguage为\"python\"的作品,且在识别到不支持的codeLanguage时会抛出TypeError错误改进tools模块的所有方法,现在临时生成的AsyncIcodeAPI会自动执行closeClient方法给tools模块的ViewNumMaker方法添加了进度提示修复了AsyncIcodeAPI.getMyWorks方法参数填入错误的bug现在IcodeAPI和AsyncIcodeAPI的cookie, info, loginStatus均改为私有成员,添加了同步方法getInfo和getLoginStatus让用户获取他们添加IcodeAPI和AsyncIcodeAPI中login方法的newCookie参数,使一个账号对象可以进行重登录添加常量DEFAULT_USER_AGENT优化注释 v1.0.2 添加server模块以快速构建响应式的有道小图灵账号机器人优化类型提示 v1.3.0 改版本号优化了server模块的大量类型提示和注释优化了server.ServerPool的并发运行方式,更改为基于进程执行器的并发添加了server.IcodeServer.CheckWorks来监听社区内作品的信息优化server.ServerPool中某些方法的返回值修复关于server.IcodeServer的results属性的bug添加tools.ResubmitAllWorks异步迭代器,用于不断重发作品优化了IcodeAPI和AsyncIcodeAPI的submitWork, reply, deleteComment, praiseComment方法的传参方式添加WorkInfoTupleGenerator和AsyncWorkInfoTupleGenerator来生成包含作品基础信息及作品发布信息的元组 v1.4.0 该版本还处于开发状态，以下新增功能仅供参考 增加server.IcodeServer的checkSame属性,用于控制API是否会重复检测同样的数据增加server.IcodeServer的stopRunning方法,并将server.IcodeServer.running改为server.IcodeServer.__running改进server.IcodeServer的CheckMessage方法,可以检测收藏消息及系统消息新增server.ServerPool的连接池重用功能server.ServerPool进程执行器可传入新增IcodeAPI.loadWork和AsyncIcodeAPI.loadWork方法,返回一个作品所需的所有asset的assetId或源代码新增tools.WorksCleaner函数以快速删除用户作品 "},"v1.0.0.html":{"url":"v1.0.0.html","title":"v1.0.0","keywords":"","body":"有什么新的内容在icodeapi v1.0.0中？ 概述 添加IcodeAPI.__init__和AsyncIcodeAPI.__init__的timeout参数增加IcodeAPI.getScratchAsset和AsyncIcodeAPI.getScratchAsset函数以获取scratch作品资源增加getUserIdFromUrl函数增加icodeapi.tools模块封装一些实用工具修复3~4个bug,给IcodeAPI.submitWork和AsyncIcodeAPI.submitWork添加workDetail参数,添加workCode参数默认值,且workType现在允许\"scratch\"和\"python\"这样的写法给IcodeAPI.getWorkDetail和AsyncIcodeAPI.getWorkDetail增加了addBrowseNum参数,优化了部分代码 设置连接池超时 现在可以设置IcodeAPI和AsyncIcodeAPI内部使用的httpx连接池的超时时间。 from icodeapi import IcodeAPI user = IcodeAPI(timeout = None) # 永不超时 workId = input(\"Enter work id: \") i = 0 while i 获取scratch作品资源 现在可以使用IcodeAPI.getScratchAsset和AsyncIcodeAPI.getScratchAsset来获取scratch作品资源。 from icodeapi import IcodeAPI user = IcodeAPI() md5ext = input('Enter asset md5ext: ') with open('asset.png', 'wb') as f: # 以二进制方式打开 data = user.getScratchAsset(md5ext = md5ext) f.write(data) # 写入文件 从网址中获取用户Id 现在可以使用getUserIdFromUrl来从网址中获取用户Id。 from icodeapi import getUserIdFromUrl print(getUserIdFromUrl('https://icodeshequ.youdao.com/personal?userId=qqCD6566A4CF1F39111AE5246D138220CA')) # qqCD6566A4CF1F39111AE5246D138220CA tools模块 新增了tools模块，封装了一些实用的函数，例如下载作品DownloadWork。文档内已增加tools模块的单独文档，想要详细了解可以前往此处。 from icodeapi.tools import DownloadWork import asyncio async def main(): workId = input('Enter work id: ') await DownloadWork(workId = workId, path = '.\\\\') # 下载到当前目录 asyncio.run(main()) 更便捷地发布作品 给IcodeAPI.submitWork和AsyncIcodeAPI.submitWork添加workDetail参数,添加workCode参数默认值,且workType现在允许\"scratch\"和\"python\"这样的写法。详细请见操作文档。 更加精细的控制 IcodeAPI.getWorkDetail和AsyncIcodeAPI.getWorkDetail添加了addBrowseNum参数，以控制在获取作品信息时是否增加浏览量。 from icodeapi import IcodeAPI user = IcodeAPI() workId = input('Enter work id: ') print(user.getWorkDetail(workId = workId, addBrowseNum = False)) "},"v1.0.1.html":{"url":"v1.0.1.html","title":"v1.0.1","keywords":"","body":"有什么新的内容在icodeapi v1.0.1中？ 概述 给tools模块增加了CommentsCleaner方法,用于异步清理评论改进tools模块的DownloadWork方法,现在它可以下载codeLanguage为\"python\"的作品,且在识别到不支持的codeLanguage时会抛出TypeError错误改进tools模块的所有方法,现在临时生成的AsyncIcodeAPI会自动执行closeClient方法给tools模块的ViewNumMaker方法添加了进度提示修复了AsyncIcodeAPI.getMyWorks方法参数填入错误的bug现在IcodeAPI和AsyncIcodeAPI的cookie, info, loginStatus均改为私有成员,添加了同步方法getInfo和getLoginStatus让用户获取他们添加IcodeAPI和AsyncIcodeAPI中login方法的newCookie参数,使一个账号对象可以进行重登录添加常量DEFAULT_USER_AGENT优化注释 评论清理者 新的异步函数tools.CommentsCleaner可以让你便捷地清除作品中的评论。 from icodeapi import AsyncIcodeAPI from icodeapi.tools import CommentsCleaner, ALL_PAGES import asyncio async def main(): api = AsyncIcodeAPI(cookie = input('Enter your cookie')) await api.login() await CommentsCleaner( input('Work ID: '), api, ALL_PAGES) await api.closeClient() asyncio.run(main()) 下载Python作品 tools.DownloadWork函数得到了升级，现在可以下载任意的Python作品，且在识别到不支持的codeLanguage时会抛出TypeError错误。 from icodeapi.tools import DownloadWork import asyncio async def main(): try: await DownloadWork( input('Work ID: '), input('Save Path: ')) except TypeError: pass except: print('Unknown Error') asyncio.run(main()) 更直观地观察刷浏览器的进度 现在，调用tools.ViewNumMaker方法会打印出部署协程的进度。 获取用户信息和登录状态的新方法 现在IcodeAPI和AsyncIcodeAPI的cookie, info, loginStatus均改为私有成员，添加了同步方法getInfo和getLoginStatus让用户获取他们。 from icodeapi import IcodeAPI cookie = input('Enter your cookie: ') user = IcodeAPI(cookie) print(user.getInfo()) print(user.getLoginStatus()) 用户对象的重新登录 现在，用户对象可以重新登录一个新的账号，只需要再调用一次IcodeAPI.login或AsyncIcodeAPI.login方法即可。该功能在TuringAPI就已经被实现，如今终于被重新加入。 from icodeapi import IcodeAPI cookie = input('Enter your cookie: ') user = IcodeAPI(cookie) print(user.getInfo()) cookie = input('Enter your new cookie: ') user = IcodeAPI(cookie) print(user.getInfo()) "},"v1.0.3.html":{"url":"v1.0.3.html","title":"v1.0.2","keywords":"","body":"有什么新的内容在icodeapi v1.0.2中？ 概述 添加server模块以快速构建响应式的有道小图灵账号机器人优化类型提示 server模块 在1.0.2版本中，我们添加了一个新的模块server，该模块旨在快速构建响应式的有道小图灵账号机器人。由于该模块功能强大，细致复杂，所以在此不会作过多介绍，想要详细了解，请前往server模块文档。示例：构建小图灵自动回复机器人。 from icodeapi import server from icodeapi import AsyncIcodeAPI api = AsyncIcodeAPI(cookie = input('Enter your cookie: ')) SERVER = server.IcodeServer(api = api) @SERVER.CheckMessage() # 持续监听消息中心 async def AutoReply(content : str, userId : str, bot : IcodeServer): # 获取新的回复的信息 try: await bot.fastReply(userId, content) # 快速回复 except AssertionError: pass except: print('Unkown Error') server.RunServer(server = SERVER) # 运行服务器 "},"v1.3.0.html":{"url":"v1.3.0.html","title":"v1.3.0","keywords":"","body":"有什么新的内容在icodeapi v1.3.0中？ 概述 改版本号优化了server模块的大量类型提示和注释优化了server.ServerPool的并发运行方式,更改为基于进程执行器的并发添加了server.IcodeServer.CheckWorks来监听社区内作品的信息优化server.ServerPool中某些方法的返回值修复关于server.IcodeServer的results属性的bug添加tools.ResubmitAllWorks异步迭代器,用于不断重发作品优化了IcodeAPI和AsyncIcodeAPI的submitWork, reply, deleteComment, praiseComment方法的传参方式添加WorkInfoTupleGenerator和AsyncWorkInfoTupleGenerator来生成包含作品基础信息及作品发布信息的元组 基于进程执行器的并发 server.ServerPool的RunServers方法现在会创建一个进程执行器，并使用该执行器来并发运行server.RunServer函数，以运行池中所有server.IcodeServer实例的run方法。以下是源代码的改造： async def RunServers(self) -> list[list]: '''Run all the servers in pool in processes''' loop = asyncio.get_event_loop() with ProcessPoolExecutor() as executor: coros = [loop.run_in_executor(executor, RunServer, i) for i in self.__servers] await asyncio.gather(* coros) return [i.results for i in self.__servers] 监听社区内作品 新增了server.IcodeServer.CheckWorks方法以监听社区作品集的所有变化。 from icodeapi import AsyncIcodeAPI from icodeapi.server import IcodeServer, RunServer cookie = input('Enter your cookie: ') user = AsyncIcodeAPI(cookie = cookie) server = IcodeServer(api = user) @server.CheckWorks() def main(works : dict): print('新的作品：') print(works) RunServer(server) BUG修复 现在server.IcodeServer.result不会再含有空列表。 重发作品异步迭代器 tools.ResubmitAllWorks可以用于不断重发作品。该迭代器每将所有已发布作品重发一次，就会yield一次asyncio.gather的返回值，返回值中包括错误和AsyncIcodeAPI.submitWork的返回值。 from icodeapi.tools import ResubmitAllWorks from icodeapi import AsyncIcodeAPI import asyncio cookie = input('Enter your cookie: ') user = AsyncIcodeAPI(cookie = cookie) async def main(): global user await user.login() async for i in ResubmitAllWorks(user): mapResult = list(map((lambda x : isinstance(x, Exception)), i)) print(f'{mapResult.count(False)}个成功，{mapResult.count(True)}个异常') await user.closeClient() asyncio.run(main()) 部分api拥有新的传参方式 现在，定义了更多类来更加方便地传参。例如IcodeAPI.submitWork的workType参数，可以传入PythonWork类来表示需要发布一个Python作品。 from icodeapi import IcodeAPI, PythonWork cookie = input('Enter your cookie: ') user = IcodeAPI(cookie = cookie) user.submitWork( 'print(\"Hello World\")', PythonWork, title = '你好，世界' ) 作品信息元组生成器 由于IcodeAPI.submitWork和AsyncIcodeAPI.submitWork的workDetail参数需要一个包含作品详细信息的元组，所以为了便利使用，两个新的函数应运而生。WorkInfoTupleGenerator和AsyncWorkInfoTupleGenerator。 from icodeapi import WorkInfoTupleGenerator, AsyncWorkInfoTupleGenerator from icodeapi import IcodeAPI, AsyncIcodeAPI import asyncio cookie = input('Enter your cookie: ') user = IcodeAPI(cookie = cookie) workId = input('Enter work id: ') print(user.submitWork( workDetail = WorkInfoTupleGenerator(user, workId), workId = workId)) async def main(): api = AsyncIcodeAPI(cookie = cookie) await api.login() print(await api.submitWork( workDetail = (await AsyncWorkInfoTupleGenerator(api, workId)), workId = workId )) await api.closeClient() asyncio.run(main()) "},"v1.4.0.html":{"url":"v1.4.0.html","title":"v1.4.0","keywords":"","body":"有什么新的内容在icodeapi v1.4.0中？ v1.4.0版本还在开发中，以下新增功能仅供参考。 概述 增加server.IcodeServer的checkSame属性,用于控制API是否会重复检测同样的数据增加server.IcodeServer的stopRunning方法,并将server.IcodeServer.running改为server.IcodeServer.__running改进server.IcodeServer的CheckMessage方法,可以检测收藏消息及系统消息新增server.ServerPool的连接池重用功能server.ServerPool进程执行器可传入新增IcodeAPI.loadWork和AsyncIcodeAPI.loadWork方法,返回一个作品所需的所有asset的assetId或源代码新增tools.WorksCleaner函数以快速删除用户作品 "},"Compare.html":{"url":"Compare.html","title":"与TuringAPI的对比","keywords":"","body":"icodeapi与TuringAPI的对比 TuringAPI是icodeapi的前身，它是第一代小图灵社区API框架，而icodeapi是第二代。icodeapi在多方面进行了改进和优化，我们强烈建议您使用icodeapi。 兼容性： icodeapi : python 3.10+TuringAPI : python 3.7+ 由此可得，TuringAPI的兼容性比icodeapi要好，最重要的是它可以在Windows7系统上使用。但是，icodeapi的功能会更加丰富！ 同步API： 功能实现：输出用户信息icodeapi: from icodeapi import IcodeAPI COOKIE = input('Enter your cookie: ') api = IcodeAPI(cookie = COOKIE) print(api.getInfo()) TuringAPI: from FinalTuringAPI import icodeUser COOKIE = input('Enter your cookie: ') api = icodeUser(cookie = COOKIE) print(api.info) 功能实现：刷浏览量icodeapi: from icodeapi import IcodeAPI COOKIE = input('Enter your cookie: ') ID = input('Enter workId: ') api = IcodeAPI(cookie = COOKIE, timeout = None) for i in range(10000): api.getWorkDetail(workId = ID, addBrowseNum = True) TuringAPI: from FinalTuringAPI import icodeUser COOKIE = input('Enter your cookie: ') ID = input('Enter workId: ') api = icodeUser(cookie = COOKIE) for i in range(10000): api.getWorkDetail(workId = ID) 功能实现：上传文件并下载回来，输出上传文件的返回值icodeapi: from icodeapi import IcodeAPI path = input(\"Enter the path to the file: \") cookie = input(\"Enter your cookie: \") api = IcodeAPI(cookie = cookie) with open(path, \"rb\") as f: result = api.uploadFile('icodeapiTesting', 'png', f.read()) print(result) with open('C:\\\\Users\\\\icodeapiSystem\\Desktop\\\\test.png', 'wb') as f: file = api.getScratchAsset(md5ext = 'icodeapiTesting.png') f.write(file) TuringAPI: from FinalTuringAPI import icodeUser from urllib3 import request path = input(\"Enter the path to the file: \") cookie = input(\"Enter your cookie: \") api = icodeUser(cookie = cookie) with open(path, \"rb\") as f: result = api.uploadFile('icodeapiTesting', 'png', f.read()) result = result.json() print(result) with open('C:\\\\Users\\\\icodeapiSystem\\Desktop\\\\test.png', 'wb') as f: result = request('GET', 'https://nos.netease.com/ydschool-online/svg/icodeapiTesting.png' ) result = result.data f.write(result) 功能实现：发布一个作品，并再重新发布一次icodeapi: from icodeapi import IcodeAPI COOKIE = input('Enter your cookie: ') api = IcodeAPI(cookie = COOKIE) workId = api.submitWork(workCode = 'Hello World', workType = 'python', title = 'icodeapi test', description = 'abc') workId = workId.get('data') info = (api.getWorkDetail(workId = workId), api.getWorkSubmitInfo(workId = workId)) api.submitWork(workDetail = info, workId = workId) TuringAPI: from FinalTuringAPI import icodeUser COOKIE = input('Enter your cookie: ') api = icodeUser(cookie = COOKIE) workId = api.submitPython('Hello World', title = 'icodeapi test', description = 'abc') workId = workId.json().get('data') data = api.getWorkDetail(workId, isParse = True) code = data.get('code') title = data.get('title') description = data.get('description') api.reSubmitPython(workId, code, title, description) 异步API： 功能实现：刷浏览量icodeapi: from icodeapi.tools import ViewNumMaker import asyncio workId = input(\"Enter workId: \") asyncio.run(ViewNumMaker(workId = workId)) TuringAPI: import FinalTuringAPI workId = input('Enter workId: ') api = FinalTuringAPI.icodeUser(None) Event = FinalTuringAPI.event(name = 'event1') for i in range(5000): FinalTuringAPI.addTask(Event, api.getWorkDetail, f'{i}', [workId]) Event.run() 功能实现：构造web服务端：icodeapi: from fastapi import FastAPI from fastapi.responses import JSONResponse from fastapi.middleware.cors import CORSMiddleware from icodeapi import AsyncIcodeAPI import uvicorn app : FastAPI = FastAPI() # 创建fastapi实例 app.add_middleware( CORSMiddleware, allow_origins=['*'], allow_credentials = True, allow_methods=['*'], allow_headers=['*'], ) api : AsyncIcodeAPI = AsyncIcodeAPI() # 实例化AsyncIcodeAPI @app.get(\"/\") async def getWork() -> JSONResponse: # 返回作品集 results = await api.getWorks() return JSONResponse(results) @app.get(\"/{workId}\") async def getWorkById(workId : str) -> JSONResponse: # 返回作品信息 results = await api.getWorkDetail(workId) return JSONResponse(results) @app.get(\"/person/{userId}\") async def getPerson(userId : str) -> JSONResponse: # 返回个人信息 results = await api.getPersonInfo(userId) return JSONResponse(results) uvicorn.run(app, host = \"0.0.0.0\", port = 80) TuringAPI:无法构建 响应式机器人： 自动回复消息：icodeapi: from icodeapi import AsyncIcodeAPI import icodeapi.server as icodeserver COOKIE = input('Enter your cookie: ') api = AsyncIcodeAPI(cookie = COOKIE) SERVER = icodeserver.IcodeServer(api = api) @SERVER.CheckMessage() async def AutoReply(content : str, userId : str, bot : icodeserver.IcodeServer): if content == 'test': await bot.fastReply(userId, 'test') icodeserver.RunServer(SERVER) TuringAPI: from FinalTuringAPI import icodeUser COOKIE = input('Enter your cookie: ') api = icodeUser(cookie = COOKIE) while True: messages = api.getMessage(1, 20, isParse = True) for i in messages: if i.get('content') == 'test': workId = api.getPersonWorks(i.get('actionUserId'), 1, 1, True) api.comment(workId[0].get('id'), 'test') 综上所述，使用Windows8及以下的用户可以选择TuringAPI，但是如果你使用Windows 8.1及以上系统，我们极力推荐你使用icodeapi！ "},"Contributing.html":{"url":"Contributing.html","title":"贡献","keywords":"","body":"贡献 感谢为icodeapi添砖加瓦的所有人！ 贡献者 冰梨IcePear冰梨是最初版TuringIO的开发者，在TuringAPI开发期间基于了下北泽工作室的开发者不少技术上的帮助，也在icodeapi开发期间给予不少帮助，是最大的贡献者。 "}}